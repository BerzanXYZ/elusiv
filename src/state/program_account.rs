use borsh::{BorshDeserialize, BorshSerialize};
use elusiv_macros::BorshSerDeSized;
use solana_program::account_info::AccountInfo;
use solana_program::program_error::ProgramError;
use solana_program::pubkey::Pubkey;

use crate::bytes::BorshSerDeSized;
use crate::types::U256;

/// This trait is used by the elusiv_instruction macro
pub trait PDAAccount {
    const SEED: &'static [u8];

    fn find(offset: Option<u64>) -> (Pubkey, u8) {
        let seed = Self::offset_seed(offset);
        let seed: Vec<&[u8]> = seed.iter().map(|x| &x[..]).collect();

        Pubkey::find_program_address(&seed, &crate::id())
    }

    fn pubkey(offset: Option<u64>, bump: u8) -> Result<Pubkey, ProgramError> {
        let mut seed = Self::offset_seed(offset);
        seed.push(vec![bump]);
        let seed: Vec<&[u8]> = seed.iter().map(|x| &x[..]).collect();

        match Pubkey::create_program_address(&seed, &crate::id()) {
            Ok(v) => Ok(v),
            Err(_) => Err(ProgramError::InvalidSeeds)
        }
    }

    fn offset_seed(offset: Option<u64>) -> Vec<Vec<u8>> {
        match offset {
            Some(offset) => vec![Self::SEED.to_vec(), offset.to_le_bytes().to_vec()],
            None => vec![Self::SEED.to_vec()]
        }
        
    }

    fn is_valid_pubkey(account: &AccountInfo, offset: Option<u64>, pubkey: &Pubkey) -> Result<bool, ProgramError> {
        let acc_data = &account.data.borrow()[..PDAAccountFields::SIZE];
        match PDAAccountFields::try_from_slice(&acc_data) {
            Ok(a) => Ok(Self::pubkey(offset, a.bump_seed)? == *pubkey),
            Err(_) => Err(ProgramError::InvalidAccountData)
        }
    }
} 

/// Every PDA account has these fields as the first fields. (elusiv_account macro guarantees this) 
#[derive(BorshDeserialize, BorshSerialize, BorshSerDeSized)]
pub struct PDAAccountFields {
    pub bump_seed: u8,
    pub initialized: bool,
}

pub trait SizedAccount {
    const SIZE: usize;
}

/// Certain accounts, like the `VerificationAccount` can be instantiated multiple times.
/// - this allows for parallel computations
/// - so we can compare this index with `MAX_INSTANCES` to check validity
pub trait MultiInstanceAccount: PDAAccount {
    const MAX_INSTANCES: u64;

    fn is_valid(&self, index: u64) -> bool {
        index < Self::MAX_INSTANCES
    }
}

// https://github.com/solana-labs/solana/blob/3608801a54600431720b37b53d7dbf88de4ead24/sdk/program/src/system_instruction.rs#L142
pub const MAX_PERMITTED_DATA_LENGTH: usize = 10 * 1024 * 1024; // 10 MiB

/// Allows for storing data across multiple accounts (needed for data sized >10 MiB)
/// - these accounts can be PDAs, but are just normal accounts
pub trait MultiAccountAccount<'t>: PDAAccount {
    /// The count of subsidiary accounts
    const COUNT: usize;

    /// The size an intermediary account has (not last account)
    const INTERMEDIARY_ACCOUNT_SIZE: usize;

    /// Returns a slice of length `Self::COUNT` containing all pubkeys of the sub-accounts
    fn get_all_pubkeys(&self) -> Vec<U256>;

    /// Set the `Self::COUNT` sub-accounts pubkeys
    fn set_all_pubkeys(&mut self, pubkeys: &[U256]);

    fn get_account(&self, account_index: usize) -> &AccountInfo<'t>;
}

macro_rules! data_slice {
    ($data: ident, $index: ident) => {
        $data[$index * Self::T::SIZE..($index + 1) * Self::T::SIZE] 
    };
}

/// Allows for storing data in an array that cannot be stored in a single Solana account
/// - `BigArrayAccount` takes care of parsing the data stored in those accounts
/// - these accounts are normal data accounts generated by extending the `BigArrayAccount`'s pda_seed
pub trait BigArrayAccount<'a>: MultiAccountAccount<'a> {
    type T: BorshSerDeSized;

    const MAX_VALUES_PER_ACCOUNT: usize = MAX_PERMITTED_DATA_LENGTH / Self::T::SIZE;

    // indices in this implementation are always the external array indices and not byte-indices!
    fn account_and_local_index(&self, index: usize) -> (usize, usize) {
        let account_index = index / Self::MAX_VALUES_PER_ACCOUNT;
        (account_index, index - account_index * Self::MAX_VALUES_PER_ACCOUNT)
    }

    // Returns the value at `index` from the correct sub-account
    fn get(&self, index: usize) -> Self::T {
        let (account_index, local_index) = self.account_and_local_index(index);
        let account = self.get_account(account_index);
        let data = &account.data.borrow_mut()[..];
        Self::T::try_from_slice(&data_slice!(data, local_index)).unwrap()
    }

    fn set(&self, index: usize, value: Self::T) {
        let (account_index, local_index) = self.account_and_local_index(index);
        let account = self.get_account(account_index);
        let data = &mut account.data.borrow_mut()[..];
        Self::T::override_slice(&value, &mut data_slice!(data, local_index));
    }
}

pub const fn max_account_size(element_size: usize) -> usize {
    MAX_PERMITTED_DATA_LENGTH / element_size
}

pub const fn big_array_accounts_count(len: usize, element_size: usize) -> usize {
    let max = MAX_PERMITTED_DATA_LENGTH / element_size;
    len / max + (if len % max == 0 { 0 } else { 1 })
}

#[cfg(test)]
mod tests {
    use super::*;

    const SEED: &'static [u8] = b"TEST_seed";

    struct TestPDAAccount {}
    impl PDAAccount for TestPDAAccount {
        const SEED: &'static [u8] = SEED;
    }

    macro_rules! account {
        ($id: ident, $pubkey: ident, $data: expr) => {
            let mut lamports = 0;
            let mut data = $data;
            let owner = crate::id();
            let $id = AccountInfo::new(
                &$pubkey,
                false, false, &mut lamports,
                &mut data,
                &owner,
                false,
                0
            );
        };
    }

    #[test]
    /// Test that the pubkeys and bumps generated by the `PDAAccount` trait are correct
    fn test_pda_account() {
        let offset = Some(12);
        let offset_bytes = u64::to_le_bytes(offset.unwrap());
        let seed = vec![SEED, &offset_bytes[..]];
        let (expected_pubkey, expected_bump) = Pubkey::find_program_address(&seed, &crate::id());

        let (result_pubkey, result_bump) = TestPDAAccount::find(offset);

        assert_eq!(TestPDAAccount::offset_seed(offset), seed);
        assert_eq!(result_pubkey, expected_pubkey);
        assert_eq!(result_bump, expected_bump);
        assert_eq!(TestPDAAccount::pubkey(offset, result_bump).unwrap(), expected_pubkey);

        // Test valid account
        account!(account, result_pubkey, vec![result_bump, 1]);
        assert!(TestPDAAccount::is_valid_pubkey(&account, offset, &expected_pubkey).unwrap());

        // Test invalid account
        account!(account, result_pubkey, vec![0, 1]);
        assert!(!TestPDAAccount::is_valid_pubkey(&account, offset, &expected_pubkey).unwrap());
    }

    #[test]
    fn test_multi_account_account() {

    }

    #[test]
    fn test_big_array_account() {

    }
}