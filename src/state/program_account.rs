use borsh::{BorshDeserialize, BorshSerialize};
use elusiv_macros::BorshSerDeSized;
use solana_program::account_info::AccountInfo;
use solana_program::program_error::ProgramError;
use solana_program::pubkey::Pubkey;

use crate::bytes::BorshSerDeSized;
use crate::types::U256;

/// This trait is used by the elusiv_instruction macro
pub trait PDAAccount {
    const SEED: &'static [u8];

    fn find(offset: Option<u64>) -> (Pubkey, u8) {
        let seed = Self::offset_seed(offset);
        let seed: Vec<&[u8]> = seed.iter().map(|x| &x[..]).collect();

        Pubkey::find_program_address(&seed, &crate::id())
    }

    fn pubkey(offset: Option<u64>, bump: u8) -> Result<Pubkey, ProgramError> {
        let mut seed = Self::offset_seed(offset);
        seed.push(vec![bump]);
        let seed: Vec<&[u8]> = seed.iter().map(|x| &x[..]).collect();

        match Pubkey::create_program_address(&seed, &crate::id()) {
            Ok(v) => Ok(v),
            Err(_) => Err(ProgramError::InvalidSeeds)
        }
    }

    fn offset_seed(offset: Option<u64>) -> Vec<Vec<u8>> {
        match offset {
            Some(offset) => vec![Self::SEED.to_vec(), offset.to_le_bytes().to_vec()],
            None => vec![Self::SEED.to_vec()]
        }
        
    }

    fn is_valid_pubkey(account: &AccountInfo, offset: Option<u64>, pubkey: &Pubkey) -> Result<bool, ProgramError> {
        let acc_data = &account.data.borrow()[..PDAAccountFields::SIZE];
        match PDAAccountFields::try_from_slice(&acc_data) {
            Ok(a) => Ok(Self::pubkey(offset, a.bump_seed)? == *pubkey),
            Err(_) => Err(ProgramError::InvalidAccountData)
        }
    }
} 

#[derive(BorshDeserialize, BorshSerialize, BorshSerDeSized)]
pub struct PDAAccountFields {
    pub bump_seed: u8,
}

pub trait SizedAccount {
    const SIZE: usize;
}

/// Certain accounts, like the `VerificationAccount` can be instantiated multiple times.
/// - this allows for parallel computations
/// - so we can compare this index with `MAX_INSTANCES` to check validity
pub trait MultiInstanceAccount: PDAAccount {
    const MAX_INSTANCES: u64;

    fn is_valid(&self, index: u64) -> bool {
        index < Self::MAX_INSTANCES
    }
}

pub const MAX_ACCOUNT_SIZE: usize = 10_000_000;

/// Allows for storing data across multiple accounts
pub trait MultiAccountAccount<'t>: PDAAccount {
    /// The count of subsidiary accounts
    const COUNT: usize;

    /// The size an intermediary account has (not last account)
    const INTERMEDIARY_ACCOUNT_SIZE: usize;

    /// Returns a slice of length `Self::COUNT` containing all pubkeys of the sub-accounts
    fn get_all_pubkeys(&self) -> Vec<U256>;

    /// Set the `Self::COUNT` sub-accounts pubkeys
    fn set_all_pubkeys(&mut self, pubkeys: &[U256]);

    fn get_account(&self, account_index: usize) -> &AccountInfo<'t>;
}

macro_rules! data_slice {
    ($data: ident, $index: ident) => {
        $data[$index * Self::T::SIZE..($index + 1) * Self::T::SIZE] 
    };
}

/// Allows for storing data in an array that cannot be stored in a single Solana account
/// - BigArrayAccount takes care of parsing the data stored in those accounts
/// - these accounts are PDA accounts generated by extending the BigArrayAccount's pda_seed
pub trait BigArrayAccount<'a>: MultiAccountAccount<'a> {
    type T: BorshSerDeSized;

    const MAX_VALUES_PER_ACCOUNT: usize = MAX_ACCOUNT_SIZE / Self::T::SIZE;

    // indices in this implementation are always the external array indices and not byte-indices!
    fn account_and_local_index(&self, index: usize) -> (usize, usize) {
        let account_index = index / Self::MAX_VALUES_PER_ACCOUNT;
        (account_index, index - account_index * Self::MAX_VALUES_PER_ACCOUNT)
    }

    fn get(&self, index: usize) -> Self::T {
        let (account_index, local_index) = self.account_and_local_index(index);
        let account = self.get_account(account_index);
        let data = &account.data.borrow_mut()[..];
        Self::T::try_from_slice(&data_slice!(data, local_index)).unwrap()
    }

    fn set(&self, index: usize, value: Self::T) {
        let (account_index, local_index) = self.account_and_local_index(index);
        let account = self.get_account(account_index);
        let data = &mut account.data.borrow_mut()[..];
        Self::T::override_slice(&value, &mut data_slice!(data, local_index));
    }
}

pub const fn max_account_size(element_size: usize) -> usize {
    MAX_ACCOUNT_SIZE / element_size
}

pub const fn big_array_accounts_count(len: usize, element_size: usize) -> usize {
    let max = MAX_ACCOUNT_SIZE / element_size;
    len / max + (if len % max == 0 { 0 } else { 1 })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_set_big_array() {
        //panic!()
        let k = Pubkey::find_program_address(&[&[1], &[2]], &crate::id());

        panic!("{} {}", k.0, k.1);
    }
}